; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -mtriple=spirv32-- -passes=infer-address-spaces %s | FileCheck %s --check-prefix=SPIRV32
; RUN: opt -S -mtriple=spirv64-- -passes=infer-address-spaces %s | FileCheck %s --check-prefix=SPIRV64

; Addrspacecasts or bitcasts must be inserted after the instructions that define their uses.

%struct.s0 = type { ptr addrspace(4), i32 }
%struct.s1 = type { %struct.s0 }

@global0 = protected addrspace(2) externally_initialized global %struct.s1 zeroinitializer

declare i32 @func(ptr %arg)

define i32 @addrspacecast_insert_pos_assert() {
; CHECK-LABEL: @addrspacecast_insert_pos_assert(
; CHECK-NEXT:    [[ALLOCA:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[LOAD0:%.*]] = load ptr addrspace(4), ptr addrspace(2) @global0, align 4
; CHECK-NEXT:    [[TMP1:%.*]] = addrspacecast ptr addrspace(4) [[LOAD0]] to ptr addrspace(1)
; CHECK-NEXT:    [[TMP2:%.*]] = addrspacecast ptr addrspace(1) [[TMP1]] to ptr addrspace(4)
; CHECK-NEXT:    [[LOAD1:%.*]] = load i32, ptr [[ALLOCA]], align 4
; CHECK-NEXT:    [[SEXT:%.*]] = sext i32 [[LOAD1]] to i64
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds i32, ptr addrspace(4) [[TMP2]], i64 [[SEXT]]
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @func(ptr addrspace(4) [[GEP]])
; CHECK-NEXT:    ret i32 [[CALL]]
;
; SPIRV32-LABEL: @addrspacecast_insert_pos_assert(
; SPIRV32-NEXT:    [[ALLOCA:%.*]] = alloca i32, align 4
; SPIRV32-NEXT:    [[LOAD0:%.*]] = load ptr addrspace(4), ptr addrspace(2) @global0, align 4
; SPIRV32-NEXT:    [[TMP1:%.*]] = addrspacecast ptr addrspace(4) [[LOAD0]] to ptr addrspace(1)
; SPIRV32-NEXT:    [[TMP2:%.*]] = addrspacecast ptr addrspace(1) [[TMP1]] to ptr addrspace(4)
; SPIRV32-NEXT:    [[LOAD1:%.*]] = load i32, ptr [[ALLOCA]], align 4
; SPIRV32-NEXT:    [[SEXT:%.*]] = sext i32 [[LOAD1]] to i64
; SPIRV32-NEXT:    [[GEP:%.*]] = getelementptr inbounds i32, ptr addrspace(4) [[TMP2]], i64 [[SEXT]]
; SPIRV32-NEXT:    [[CALL:%.*]] = call i32 @func(ptr addrspace(4) [[GEP]])
; SPIRV32-NEXT:    ret i32 [[CALL]]
;
; SPIRV64-LABEL: @addrspacecast_insert_pos_assert(
; SPIRV64-NEXT:    [[ALLOCA:%.*]] = alloca i32, align 4
; SPIRV64-NEXT:    [[LOAD0:%.*]] = load ptr addrspace(4), ptr addrspace(2) @global0, align 8
; SPIRV64-NEXT:    [[TMP1:%.*]] = addrspacecast ptr addrspace(4) [[LOAD0]] to ptr addrspace(1)
; SPIRV64-NEXT:    [[TMP2:%.*]] = addrspacecast ptr addrspace(1) [[TMP1]] to ptr addrspace(4)
; SPIRV64-NEXT:    [[LOAD1:%.*]] = load i32, ptr [[ALLOCA]], align 4
; SPIRV64-NEXT:    [[SEXT:%.*]] = sext i32 [[LOAD1]] to i64
; SPIRV64-NEXT:    [[GEP:%.*]] = getelementptr inbounds i32, ptr addrspace(4) [[TMP2]], i64 [[SEXT]]
; SPIRV64-NEXT:    [[CALL:%.*]] = call i32 @func(ptr addrspace(4) [[GEP]])
; SPIRV64-NEXT:    ret i32 [[CALL]]
;
  %alloca = alloca i32, align 4
  %cast = addrspacecast ptr %alloca to ptr addrspace(4)
  %load0 = load ptr addrspace(4), ptr addrspace(2) @global0
  %load1 = load i32, ptr addrspace(4) %cast
  %sext = sext i32 %load1 to i64
  %gep = getelementptr inbounds i32, ptr addrspace(4) %load0, i64 %sext
  %call = call i32 @func(ptr addrspace(4) %gep)
  ret i32 %call
}

define void @bitcast_insert_pos_assert_1() {
; CHECK-LABEL: @bitcast_insert_pos_assert_1(
; CHECK-NEXT:  bb.0:
; CHECK-NEXT:    [[ASC0:%.*]] = addrspacecast ptr undef to ptr addrspace(4)
; CHECK-NEXT:    [[PTI0:%.*]] = ptrtoint ptr addrspace(4) [[ASC0]] to i64
; CHECK-NEXT:    br label [[BB_1:%.*]]
; CHECK:       bb.1:
; CHECK-NEXT:    br i1 undef, label [[BB_2:%.*]], label [[BB_3:%.*]]
; CHECK:       bb.2:
; CHECK-NEXT:    [[PTI1:%.*]] = ptrtoint ptr addrspace(4) [[ASC0]] to i64
; CHECK-NEXT:    [[ITP0:%.*]] = inttoptr i64 [[PTI1]] to ptr addrspace(4)
; CHECK-NEXT:    [[LOAD0:%.*]] = load ptr addrspace(4), ptr addrspace(4) [[ITP0]], align 8
; CHECK-NEXT:    br label [[BB_3]]
; CHECK:       bb.3:
; CHECK-NEXT:    ret void
;
; SPIRV32-LABEL: @bitcast_insert_pos_assert_1(
; SPIRV32-NEXT:  bb.0:
; SPIRV32-NEXT:    [[ASC0:%.*]] = addrspacecast ptr undef to ptr addrspace(4)
; SPIRV32-NEXT:    [[PTI0:%.*]] = ptrtoint ptr addrspace(4) [[ASC0]] to i64
; SPIRV32-NEXT:    br label [[BB_1:%.*]]
; SPIRV32:       bb.1:
; SPIRV32-NEXT:    br i1 undef, label [[BB_2:%.*]], label [[BB_3:%.*]]
; SPIRV32:       bb.2:
; SPIRV32-NEXT:    [[PTI1:%.*]] = ptrtoint ptr addrspace(4) [[ASC0]] to i64
; SPIRV32-NEXT:    [[ITP0:%.*]] = inttoptr i64 [[PTI1]] to ptr addrspace(4)
; SPIRV32-NEXT:    [[LOAD0:%.*]] = load ptr addrspace(4), ptr addrspace(4) [[ITP0]], align 8
; SPIRV32-NEXT:    br label [[BB_3]]
; SPIRV32:       bb.3:
; SPIRV32-NEXT:    ret void
;
; SPIRV64-LABEL: @bitcast_insert_pos_assert_1(
; SPIRV64-NEXT:  bb.0:
; SPIRV64-NEXT:    [[ASC0:%.*]] = addrspacecast ptr undef to ptr addrspace(4)
; SPIRV64-NEXT:    [[PTI0:%.*]] = ptrtoint ptr addrspace(4) [[ASC0]] to i64
; SPIRV64-NEXT:    br label [[BB_1:%.*]]
; SPIRV64:       bb.1:
; SPIRV64-NEXT:    br i1 undef, label [[BB_2:%.*]], label [[BB_3:%.*]]
; SPIRV64:       bb.2:
; SPIRV64-NEXT:    [[LOAD0:%.*]] = load ptr addrspace(4), ptr undef, align 8
; SPIRV64-NEXT:    br label [[BB_3]]
; SPIRV64:       bb.3:
; SPIRV64-NEXT:    ret void
;
bb.0:
  %asc0 = addrspacecast ptr undef to ptr addrspace(4)
  %pti0 = ptrtoint ptr addrspace(4) %asc0 to i64
  br label %bb.1

bb.1:
  br i1 undef, label %bb.2, label %bb.3

bb.2:
  %pti1 = ptrtoint ptr addrspace(4) %asc0 to i64
  %itp0 = inttoptr i64 %pti1 to ptr addrspace(4)
  %load0 = load ptr addrspace(4), ptr addrspace(4) %itp0, align 8
  br label %bb.3

bb.3:
  ret void
}

define void @bitcast_insert_pos_assert_2() {
; CHECK-LABEL: @bitcast_insert_pos_assert_2(
; CHECK-NEXT:    [[ALLOCA0:%.*]] = alloca [[STRUCT_S1:%.*]], align 16
; CHECK-NEXT:    [[ASC0:%.*]] = addrspacecast ptr [[ALLOCA0]] to ptr addrspace(4)
; CHECK-NEXT:    [[PTI0:%.*]] = ptrtoint ptr addrspace(4) [[ASC0]] to i64
; CHECK-NEXT:    [[ITP0:%.*]] = inttoptr i64 [[PTI0]] to ptr addrspace(4)
; CHECK-NEXT:    [[ITP1:%.*]] = ptrtoint ptr addrspace(4) [[ASC0]] to i64
; CHECK-NEXT:    [[ITP2:%.*]] = inttoptr i64 [[ITP1]] to ptr addrspace(4)
; CHECK-NEXT:    [[GEP0:%.*]] = getelementptr i64, ptr addrspace(4) [[ITP2]], i64 1
; CHECK-NEXT:    ret void
;
; SPIRV32-LABEL: @bitcast_insert_pos_assert_2(
; SPIRV32-NEXT:    [[ALLOCA0:%.*]] = alloca [[STRUCT_S1:%.*]], align 16
; SPIRV32-NEXT:    [[ASC0:%.*]] = addrspacecast ptr [[ALLOCA0]] to ptr addrspace(4)
; SPIRV32-NEXT:    [[PTI0:%.*]] = ptrtoint ptr addrspace(4) [[ASC0]] to i64
; SPIRV32-NEXT:    [[ITP0:%.*]] = inttoptr i64 [[PTI0]] to ptr addrspace(4)
; SPIRV32-NEXT:    [[ITP1:%.*]] = ptrtoint ptr addrspace(4) [[ASC0]] to i64
; SPIRV32-NEXT:    [[ITP2:%.*]] = inttoptr i64 [[ITP1]] to ptr addrspace(4)
; SPIRV32-NEXT:    [[GEP0:%.*]] = getelementptr i64, ptr addrspace(4) [[ITP2]], i64 1
; SPIRV32-NEXT:    ret void
;
; SPIRV64-LABEL: @bitcast_insert_pos_assert_2(
; SPIRV64-NEXT:    [[ALLOCA0:%.*]] = alloca [[STRUCT_S1:%.*]], align 16
; SPIRV64-NEXT:    [[ASC0:%.*]] = addrspacecast ptr [[ALLOCA0]] to ptr addrspace(4)
; SPIRV64-NEXT:    [[PTI0:%.*]] = ptrtoint ptr addrspace(4) [[ASC0]] to i64
; SPIRV64-NEXT:    [[ITP0:%.*]] = inttoptr i64 [[PTI0]] to ptr addrspace(4)
; SPIRV64-NEXT:    [[TMP1:%.*]] = addrspacecast ptr [[ALLOCA0]] to ptr addrspace(4)
; SPIRV64-NEXT:    [[GEP0:%.*]] = getelementptr i64, ptr addrspace(4) [[TMP1]], i64 1
; SPIRV64-NEXT:    ret void
;
  %alloca0 = alloca %struct.s1, align 16
  %asc0 = addrspacecast ptr %alloca0 to ptr addrspace(4)
  %pti0 = ptrtoint ptr addrspace(4) %asc0 to i64
  %itp0 = inttoptr i64 %pti0 to ptr addrspace(4)
  %itp1 = ptrtoint ptr addrspace(4) %asc0 to i64
  %itp2 = inttoptr i64 %itp1 to ptr addrspace(4)
  %gep0 = getelementptr i64, ptr addrspace(4) %itp2, i64 1
  ret void
}
